# 控制并发流程【做好线程之间的协调人】

## 并发控制工具类概览

![image-20200825102310783](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20200825102310783.png)

## CountDownLatch倒计时门闩

### CountDown使用场景

1. 一个线程等多个线程执行完成

   在媒体处理中，拼接命令需要等所有待拼接的任务下载完成后才执行。

2. 多个线程等一个线程执行完

   压测场景下，所有线程等一声令下立马向服务器施加压力，而不是还去慢悠悠的创建线程。

3. 多等多

### 作用

倒数门闩
例子:购物拼团;大巴(游乐园坐过山车排队),人满发车。
流程:倒数结束之前,一直处于等待状态,直到倒计时结束了此线程才継续工作。

![image-20200825103137355](C:\Users\HP\AppData\Roaming\Typora\typora-user-images\image-20200825103137355.png)

### 主要方法介绍

1. Countdownlatch( Int count)：仅有一个构造函数,参数 count为需要倒数的数值。
2. await()：调用 awalt0方法的线程会被挂起,它会等待直到 count
   值为0才继续执行。
3. countdown()：将 countf值减1,直到为0时,等待的线程会被唤
   起

### 两种用法

#### 用法ー:一个线程等待多个线程部执行完毕,再继续自己的工作。

#### 用法ニ:多个线程等待某一个线程的信号,同时开始执行。

### 注意点

### 原理、源码分析

### 原理

###### AQS

##### 结构图

##### CountDownLatch源码分析

###### 这里对CountDownLatch类里面最重要的3个方法进行分析

###### 构造方法

####### CountDownLatch仅提供了一个构造方法，接收的参数就是需要计数的数量，直到countDown()方法被调用到了规定的次数，之前在等待的线程才会继续工作。

####### 源码

######## public CountDownLatch(int count) {    if (count < 0) throw new IllegalArgumentException("count < 0");    this.sync = new Sync(count);}

###### await()

####### 调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行

###### countDown()

####### public void countDown() {    sync.releaseShared(1);}

#### 总结

##### CountDownLatch类在创建实例的时候，需要传递倒数次数。

##### 而每一次线程调用了await()方法，state变量会减一，直到为0。

##### state为0的时候，之前等待的线程会继续运行。

##### CountDownLatch不能回滚重置。

### Semaphore信号量

#### 介绍

##### Semaphore可以用来限制或管理数量有限的资源的使用情况。

##### 信号量的作用是维护一个“许可证”的计数，线程可以“获取”许可证，那信号量剩余的许可证就减一，线程也可以“是否”一个许可证，那信号量剩余的许可证就加一，当信号量所拥有的许可证数量为0，那么下一个还想要获取许可证的线程，就需要等待，直到有另外的线程释放了许可证。

#### 使用场景、应用实例

##### 背景

##### 正常情况下获取许可证

##### 没许可证时，会阻塞前来请求的线程

##### 有线程释放信号量后

##### 如果有两个线程释放许可证

##### 总结

#### 用法

##### 使用流程

##### 主要方法介绍

###### new Semaphore(int permits, boolean fair)

###### tryAcquire()

###### tryAcquire(timeout)

###### availablePermits

###### acquire()

###### acquireUninterruptibly()

###### release()

##### 示例代码

##### 特殊用法

###### 一次性获取或释放多个许可证

####### 使用场景

######## 比如TaskA会调用很消耗资源的method1()，而TaskB调用的是不太消耗资源的method2()，假设我们一共有5个许可证。那么我们就可以要求TaskA获取5个许可证才能执行，而TaskB只需要获取到一个许可证就能执行，这样就避免了A和B同时运行的情况，我们可以根据自己的需求合理分配资源。

#### 注意点

##### 1.	获取和释放的许可证数量必须一致，否则比如每次都获取2个但是只释放1个甚至不释放，随着时间的推移，到最后许可证数量不够用，会导致程序卡死。（虽然信号量类并不对是否和获取的数量做规定，但是这是我们的编程规范，否则容易出错）

##### 2.	注意在初始化Semaphore的时候设置公平性，一般设置为true会更合理

##### 3.	并不是必须由获取许可证的线程释放那个许可证，事实上，获取和释放许可证对线程并无要求，也许是A获取了，然后由B释放，只要逻辑合理即可。

##### 4.	信号量的作用，除了控制临界区最多同时有N个线程访问外，另一个作用是可以实现“条件等待”，例如线程1需要在线程2完成准备工作后才能开始工作，那么就线程1acquire()，而线程2完成任务后release()，这样的话，相当于是轻量级的CountDownLatch。

##### 5.	可以跨线程/跨线程池共享同一个信号量。

### Condition接口（又称条件对象）

#### 作用

##### 当线程1需要等待某个条件的时候，它就去执行condition.await()方法，一旦执行了await()方法，线程就会进入阻塞状态。

##### 然后通常会有另外一个线程，假设是线程2，去执行对应的条件，直到这个条件达成的时候，线程2就会去执行condition.signal()方法，这时JVM就会从被阻塞的线程里找，找到那些等待该condition的线程，当线程1就会收到可执行信号的时候，它的线程状态就会变成Runnable可执行状态。

##### signalAll()和signal()区别

###### signalAll()会唤起所有的正在等待的线程。

###### 但是signal()是公平的，只会唤起那个等待时间最长的线程，在当前情况下，是thread-0。

#### 代码演示

##### 普通示例

##### 用Condition实现生产者消费者模式

#### 注意点

#### 源码分析

#### 面试常见问题

##### Condition和object.wait()和notify()的关系？

### CyclicBarrier循环栅栏

#### 作用

#### 代码例子

#### 面试常见问题

##### CyclicBarriar 和 CountdownLatch 有什么区别？