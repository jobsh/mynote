# 01 Foodie-Cloud 微服务项目模块结构

## Domain外部划分

foodie-search：主搜模块

foodie-item：商品中心模块：电商的所有上下游链路都是围绕**商品中心**来展开的，在我们项目中商品中心是一个相对比较粗的划分模块，在淘宝这个的企业级电商中，一般商品中心都要拆分成十几个甚至二十几个的微服务模块。比如商品中心中还可以包括：营销优惠、商品优惠券、评论模块、商品详情页。

foodie-cart：购物车模块：介于商品域和订单域中间的一个模块。

foodie-auth：权限验证校验模块：会和网关层结合。在真实项目中，用户鉴权并非全是在网关层完成的，很多情况下我们也会把鉴权下放到服务端。

foodie-user：用户中心模块：用户注册、Customer-profile的更新操作、用户信息的查询。

foodie-order：订单的创建、更新，依赖于foodie-item模块、下单时需要获取用户信息，因此也依赖于foodie-user模块

## Domain内部划分

微服务改造前的当前工程结构：foodie-api、foodie-service、foodie-mapper、foodie-pojo、foodie-common

在此次我们微服务改造的过程中的，我们秉承一个准则：对现有的工程结构尽量少做改动。

Foodie-api：我们之前的api层相当于controller层，用来放controller的，在这次微服务升级过程中，把api层做成了纯接口层，纯接口层顾名思义只用来放java的接口，即interface，我们为什么要把接口单独抽出来呢？原因有以下几点：因为我们会牵扯到不同模块的微服务调用，在多个微服务间通过Feign（会在后面服务调用时学习）相互调用时，只需要把对方的接口引入进来即可，并不需要接口的实现引用进来，所以剥离出接口层是为了专门给那些需要调用我的服务来使用的，比如foodie-order订单服务需要foodie-item为其提供一些服务，那么在我的订单服务中只需要把foodie-item的相关接口层引用进来，再借助Feign组件就可以很方便地发起一个从订单中心到商品中心的服务调用。

而原来的foodie-api变成了foodie-web，用来存放controller。

foodie-service迁移过来还是foodie-service，在实际的项目中，我们可以把foodie-web和foodie-service二合一，因为本质上他们都是接口。只不过一个是和UI层打交道，一个是在服务内部打交道。这里没有合并是为了和初始的项目保持一致。

foodie-mapper：迁移过来，无变化。

foodie-pojo：无变化。

foodie-common：// todo

除上面以外，在微服务领域当中，数据库是每一个模块是有自己独立的scheme。

## Foodie-Search

商品搜索

类目搜索

轮播图列表

以上三种服务是从原来的ItemService剥离出来的

手动移植ES功能，后面学习熔断降级的过程中也会到搜索模块做一些降级策略

## Foodie-Item

商品详情页（ID）：在真实的电商项目中，商品详情页更多承担的一个聚合接口的角色。因为要在商品详情页中显示很多的信息，比如用户的点赞数，营销优惠的价格、商品原件、商品打折后的价格等

商品所能参加的所有活动，商品的主图、商品的附图、商品富文本。

获取SKU等

商品库存，库存扣减在超高并发中是如何做的呢，库存扣减最终一定是落在数据库当中的，这就是强一致性，那么如果大量的用户同时操作数据库去扣减库存，那么为了保证数据的安全性，就需要给这条记录上**行锁**，这样做的话，无疑对数据库的性能是个巨大的考验。

主图

## Foodie-Cart

添加商品到购物车

购物车商品的同步

购物车商品的修改和删除

## Foodie-Order

前端价格校验

创建订单

查询订单

订单状态、修改

关闭超时订单

## Foodie-Auth

生成Token

Token校验

Token更新

Gateway集成

# 该微服务改造项目是基于第三章的redis版本进行的改造

